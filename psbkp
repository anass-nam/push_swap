#include "push_swap.h"

#define TOP 0
#define DIVIDER 5

static int	get_pos(int *arr, int l, int r, int val)
{
	int	m;

	if (r - l > 1)
	{
		m = (l + (r - l) / 2);
		if (arr[m] > val)
			r = m;
		else
			l = m;
		return (get_pos(arr, l, r, val));
	}
	return (r);
}

t_byte	rotate_direction(t_array *a, int min, int max)
{
	int	i;
	int	first;
	int	last;

	i = -1;
	first = a->size - 1;
	last = 0;
	while (++i < a->size)
	{
		if (a->items[i] >= min && a->items[i] <= max)
		{
			if (i < first)
				first = i;
			if (i > last)
				last = i;
		}
	}

	if (first < a->size / 4 || last < a->size - a->size / 2)
		return (RA);
	return (RRA);
}

static void	divide_items(t_stack *s)
{
	int	shank;
	int	half_shank;
	int	i;

	shank = s->max / (DIVIDER + (s->max >= 500) * 5);
	if (shank < 2)
		shank = s->max;
	half_shank = shank / 2;
	i = 0;
	while (s->a->size > 3)
	{
		if (s->a->items[TOP] < s->max - 2 && s->a->items[TOP] <= shank)
		{
			call(s, PB);
			if (s->b->size > 1 && s->b->items[TOP] <= shank - half_shank)
			{
				if (s->a->items[TOP] > shank)
					call(s, RR);
				else
					call(s, RB);
			}
			i++;
		}
		else
			call(s, rotate_direction(s->a, shank - s->max / (DIVIDER + (s->max >= 500) * 5), shank));
		if (i == shank)
			shank += half_shank * 2;
	}
}

static void	merge_items(t_stack *s)
{
	int	range;
	int	max;
	int	sa_flag;

	range = (s->max / (DIVIDER + (s->max >= 500) * 5)) / 2 * sizeof(int);
	if (range < 4)
		range = s->b->size * sizeof(int);
	sa_flag = 0;
	while (s->b->size)
	{
		max = s->b->size + sa_flag;
		if (ft_memchr(s->b->items, max, range))
		{
			if (max == s->b->items[TOP])
			{
				call(s, PA);
				if (sa_flag)
				{
					if (s->b->items[TOP] < s->b->items[TOP + 1])
						call(s, SS);
					else
						call(s, SA);
					sa_flag = 0;
				}
			}
			else if (max - 1 == s->b->items[TOP])
			{
				call(s, PA);
				sa_flag = 1;
			}
			else
				call(s, RB);
		}
		else
			call(s, RRB);
	}
}

void	push_swap(t_stack *s)
{
	int	i;

	divide_items(s);
	//	sort left 3 items
	while (!(s->a->items[0] < s->a->items[1] && s->a->items[1] < s->a->items[2]))
	{
		if (s->a->items[0] < s->a->items[1] && s->a->items[0] > s->a->items[2])
			call(s, RRA);
		else if (s->a->items[0] > s->a->items[1] && s->a->items[0] > s->a->items[2])
			call(s, RA);
		else
			call(s, SA);
	}
	merge_items(s);
}
/*

t_byte	rotate_direction(t_array *a, int min, int max)
{
	int	i;
	int	j;

	i = 0;
	while (i < a->size && !(a->items[i] >= min && a->items[i] <= max))
		i++;
	j = a->size - 1;
	while (j >= 0 && !(a->items[i] >= min && a->items[i] <= max))
		j--;
	if (i <= a->size - j)// && a->items[i] < a->items[j])
		return (RA);
	return (RRA);
}

static void	divide_items(t_stack *s)
{
	int	shank;
	int	half_shank;
	int	i;

	shank = s->max / (s->max / DIVIDER + (s->max <= 100) * 2);
	if (shank < 2)
		shank = s->max;
	half_shank = shank / 2;
	i = 0;
	while (s->a->size > 3)
	{
		if (s->a->items[TOP] < s->max - 2 && s->a->items[TOP] <= shank)
		{
			call(s, PB);
			if (s->b->size > 1 && s->b->items[TOP] <= shank - half_shank)
				call(s, RB);
			i++;
		}
		else
			call(s, rotate_direction(s->a, shank - s->max / (s->max / DIVIDER + (s->max <= 100) * 2), shank));
			call(s, RA);
		if (i == shank)
			shank += half_shank * 2;
	}
}




*/